using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

namespace BaroLib
{
    public static class ToolBox
    {
        /// <summary>
        ///     Cleans up a path by replacing backslashes with forward slashes, and
        ///     optionally corrects the casing of the path. Recommended when serializing
        ///     paths to a human-readable file to force case correction on all platforms.
        ///     Also useful when working with paths to files that currently don't exist,
        ///     i.e. case cannot be corrected.
        /// </summary>
        /// <param name="path">Path to clean up</param>
        /// <param name="correctFilenameCase">Should the case be corrected to match the filesystem?</param>
        /// <param name="directory">Directories that the path should be found in, not returned.</param>
        /// <returns>Path with corrected slashes, and corrected case if requested.</returns>
        public static string CleanUpPathCrossPlatform(this string path, bool correctFilenameCase = true, string directory = "")
        {
            if (string.IsNullOrEmpty(path))
            {
                return "";
            }

            path = path
                .Replace('\\', '/');
            if (path.StartsWith("file:", StringComparison.OrdinalIgnoreCase))
            {
                path = path.Substring("file:".Length);
            }

            while (path.IndexOf("//") >= 0)
            {
                path = path.Replace("//", "/");
            }

            if (correctFilenameCase)
            {
                string correctedPath = CorrectFilenameCase(path, out _, directory);
                if (!string.IsNullOrEmpty(correctedPath))
                {
                    path = correctedPath;
                }
            }

            return path;
        }

        public static string CorrectFilenameCase(string filename, out bool corrected, string directory = "")
        {
            char[]   delimiters       = { '/', '\\' };
            string[] subDirs          = filename.Split(delimiters);
            string   originalFilename = filename;
            filename  = "";
            corrected = false;

            if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && File.Exists(originalFilename))
            {
                return originalFilename;
            }

            if (Path.IsPathRooted(originalFilename))
            {
                return
                    originalFilename; //assume that rooted paths have correct case since these are generated by the game
            }

            string startPath = directory ?? "";

            for (var i = 0; i < subDirs.Length; i++)
            {
                if (i == subDirs.Length - 1 && string.IsNullOrEmpty(subDirs[i]))
                {
                    break;
                }

                string subDir   = subDirs[i].TrimEnd();
                string enumPath = Path.Combine(startPath, filename);

                if (string.IsNullOrWhiteSpace(filename))
                {
                    enumPath = string.IsNullOrWhiteSpace(startPath) ? "./" : startPath;
                }

                List<string> filePaths = Directory.GetFileSystemEntries(enumPath).Select(Path.GetFileName).ToList();

                if (filePaths.Any(s => s.Equals(subDir, StringComparison.Ordinal)))
                {
                    filename += subDir;
                }
                else
                {
                    List<string> correctedPaths =
                        filePaths.Where(s => s.Equals(subDir, StringComparison.OrdinalIgnoreCase)).ToList();
                    if (correctedPaths.Any())
                    {
                        corrected =  true;
                        filename  += correctedPaths.First();
                    }
                    else
                    {
                        //DebugConsole.ThrowError($"File \"{originalFilename}\" not found!");
                        corrected = false;
                        return originalFilename;
                    }
                }

                if (i < subDirs.Length - 1)
                {
                    filename += "/";
                }
            }

            return filename;
        }
    }
}
